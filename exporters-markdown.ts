/**
 * Markdown exporter for timeline events
 * Generates clean Markdown files with date headers and clickable links
 */

import { promises as fs } from 'fs';
import { DateTime } from 'luxon';
import path from 'path';
import { TimelineEvent, TimelineConfig } from './types.js';

export class MarkdownExporter {
  /**
   * Export timeline events to a Markdown file
   */
  async export(events: TimelineEvent[], config: TimelineConfig): Promise<string> {
    const outputDir = config.output.outputDir || './timeline-output';
    const filename = `timeline-${config.target.replace(/[^a-zA-Z0-9]/g, '_')}-${DateTime.now().toFormat('yyyy-MM-dd')}.md`;
    const filepath = path.join(outputDir, filename);

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Group events by date
    const groupedEvents = this.groupEventsByDate(events);
    
    // Generate Markdown content
    const markdown = this.generateMarkdown(groupedEvents, config);
    
    // Write to file
    await fs.writeFile(filepath, markdown, 'utf-8');
    
    return filepath;
  }

  /**
   * Group events by date for better organization
   */
  private groupEventsByDate(events: TimelineEvent[]): Map<string, TimelineEvent[]> {
    const grouped = new Map<string, TimelineEvent[]>();

    for (const event of events) {
      const dateKey = event.timestamp.toISODate();
      if (!dateKey) continue;

      if (!grouped.has(dateKey)) {
        grouped.set(dateKey, []);
      }
      grouped.get(dateKey)!.push(event);
    }

    // Sort dates in descending order (most recent first)
    return new Map([...grouped.entries()].sort((a, b) => b[0].localeCompare(a[0])));
  }

  /**
   * Generate the complete Markdown document
   */
  private generateMarkdown(groupedEvents: Map<string, TimelineEvent[]>, config: TimelineConfig): string {
    const lines: string[] = [];

    // Header
    lines.push(`# Activity Timeline: ${config.target}`);
    lines.push('');
    lines.push(`**Generated:** ${DateTime.now().toFormat('MMMM dd, yyyy \'at\' HH:mm')} (${config.timezone})`);
    lines.push(`**Platforms:** ${config.platforms.join(', ')}`);
    
    if (config.dateRange) {
      lines.push(`**Date Range:** ${config.dateRange.start.toISODate()} to ${config.dateRange.end.toISODate()}`);
    }
    
    lines.push('');
    lines.push('---');
    lines.push('');

    // Summary statistics
    const totalEvents = Array.from(groupedEvents.values()).reduce((sum, events) => sum + events.length, 0);
    const platformStats = this.getPlatformStats(groupedEvents);
    
    lines.push('## Summary');
    lines.push('');
    lines.push(`- **Total Events:** ${totalEvents}`);
    lines.push(`- **Active Days:** ${groupedEvents.size}`);
    lines.push('- **Events by Platform:**');
    
    for (const [platform, count] of Object.entries(platformStats)) {
      lines.push(`  - ${this.capitalize(platform)}: ${count}`);
    }
    
    lines.push('');
    lines.push('---');
    lines.push('');

    // Timeline events grouped by date
    lines.push('## Timeline');
    lines.push('');

    for (const [dateKey, events] of groupedEvents) {
      const date = DateTime.fromISO(dateKey);
      const dayName = date.toFormat('cccc');
      const formattedDate = date.toFormat('MMMM dd, yyyy');
      
      // Date header
      lines.push(`### ${dayName}, ${formattedDate}`);
      lines.push('');

      // Sort events by time (most recent first)
      const sortedEvents = events.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());

      for (const event of sortedEvents) {
        lines.push(this.formatEventAsMarkdown(event));
        lines.push('');
      }

      lines.push('---');
      lines.push('');
    }

    // Footer
    lines.push('## Legend');
    lines.push('');
    lines.push('**Platform Icons:**');
    lines.push('- 🐦 Twitter');
    lines.push('- 🤖 Reddit');
    lines.push('- 💻 GitHub');
    lines.push('- 📰 RSS/Blog');
    lines.push('- 📋 Pastebin');
    lines.push('');
    lines.push('**Event Types:**');
    lines.push('- 📝 Post/Tweet');
    lines.push('- 💬 Comment/Reply');
    lines.push('- ⭐ Reaction/Like');
    lines.push('- 🔧 Code Commit');
    lines.push('- 🆕 Create Repository');
    lines.push('- 📤 Push/Deploy');
    lines.push('- 🔀 Pull Request');
    lines.push('- 📄 Blog Post');
    lines.push('- 📋 Code Snippet');
    lines.push('');
    lines.push(`*Timeline generated by Cross-Platform Activity Timeline Builder*`);

    return lines.join('\n');
  }

  /**
   * Format a single event as Markdown
   */
  private formatEventAsMarkdown(event: TimelineEvent): string {
    const time = event.timestamp.toFormat('HH:mm');
    const platformIcon = this.getPlatformIcon(event.platform);
    const categoryIcon = this.getCategoryIcon(event.category);
    
    const lines: string[] = [];
    
    // Event header with time and icons
    lines.push(`**${time}** ${platformIcon} ${categoryIcon} **[${event.title}](${event.url})**`);
    
    // Content (truncated if too long)
    if (event.content) {
      const truncatedContent = event.content.length > 200 
        ? event.content.substring(0, 200) + '...'
        : event.content;
      
      lines.push(`> ${truncatedContent.replace(/\n/g, ' ')}`);
    }
    
    // Metadata
    const metadata: string[] = [];
    
    if (event.username && event.username !== 'unknown') {
      metadata.push(`👤 @${event.username}`);
    }
    
    if (event.metadata.score !== undefined) {
      metadata.push(`⭐ ${event.metadata.score}`);
    }
    
    if (event.metadata.numComments !== undefined) {
      metadata.push(`💬 ${event.metadata.numComments}`);
    }
    
    if (event.metadata.repository) {
      metadata.push(`📁 ${event.metadata.repository}`);
    }
    
    if (metadata.length > 0) {
      lines.push(`*${metadata.join(' • ')}*`);
    }

    return lines.join('  \n'); // Two spaces for line break in Markdown
  }

  /**
   * Get platform statistics
   */
  private getPlatformStats(groupedEvents: Map<string, TimelineEvent[]>): Record<string, number> {
    const stats: Record<string, number> = {};
    
    for (const events of groupedEvents.values()) {
      for (const event of events) {
        stats[event.platform] = (stats[event.platform] || 0) + 1;
      }
    }
    
    return stats;
  }

  /**
   * Get platform icon/emoji
   */
  private getPlatformIcon(platform: string): string {
    const icons: Record<string, string> = {
      twitter: '🐦',
      reddit: '🤖',
      github: '💻',
      rss: '📰',
      pastebin: '📋'
    };
    return icons[platform] || '📱';
  }

  /**
   * Get category icon/emoji
   */
  private getCategoryIcon(category: string): string {
    const icons: Record<string, string> = {
      post: '📝',
      comment: '💬',
      share: '🔄',
      reaction: '⭐',
      code_commit: '🔧',
      code_create: '🆕',
      code_push: '📤',
      code_pr: '🔀',
      blog_post: '📄',
      article: '📰',
      paste: '📋',
      snippet: '📋',
      other: '📎'
    };
    return icons[category] || '📎';
  }

  /**
   * Capitalize first letter of a string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}