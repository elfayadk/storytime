/**
 * Markdown exporter for timeline events
 * Generates clean Markdown files with date headers and clickable links
 */

import { promises as fs } from 'fs';
import { DateTime } from 'luxon';
import path from 'path';
import { TimelineEvent, TimelineConfig } from './types.js';

export class MarkdownExporter {
  /**
   * Export timeline events to a Markdown file
   */
  async export(events: TimelineEvent[], config: TimelineConfig): Promise<string> {
    const outputDir = config.output.outputDir || './timeline-output';
    const filename = `timeline-${config.target.replace(/[^a-zA-Z0-9]/g, '_')}-${DateTime.now().toFormat('yyyy-MM-dd')}.md`;
    const filepath = path.join(outputDir, filename);

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Group events by date
    const groupedEvents = this.groupEventsByDate(events);
    
    // Generate Markdown content
    const markdown = this.generateMarkdown(groupedEvents, config);
    
    // Write to file
    await fs.writeFile(filepath, markdown, 'utf-8');
    
    return filepath;
  }

  /**
   * Group events by date for better organization
   */
  private groupEventsByDate(events: TimelineEvent[]): Map<string, TimelineEvent[]> {
    const grouped = new Map<string, TimelineEvent[]>();

    for (const event of events) {
      const dateKey = event.timestamp.toISODate();
      if (!dateKey) continue;

      if (!grouped.has(dateKey)) {
        grouped.set(dateKey, []);
      }
      grouped.get(dateKey)!.push(event);
    }

    // Sort dates in descending order (most recent first)
    return new Map([...grouped.entries()].sort((a, b) => b[0].localeCompare(a[0])));
  }

  /**
   * Generate the complete Markdown document
   */
  private generateMarkdown(groupedEvents: Map<string, TimelineEvent[]>, config: TimelineConfig): string {
    const lines: string[] = [];

    // Header
    lines.push(`# Activity Timeline: ${config.target}`);
    lines.push('');
    lines.push(`**Generated:** ${DateTime.now().toFormat('MMMM dd, yyyy \'at\' HH:mm')} (${config.timezone})`);
    lines.push(`**Platforms:** ${config.platforms.join(', ')}`);
    
    if (config.dateRange) {
      lines.push(`**Date Range:** ${config.dateRange.start.toISODate()} to ${config.dateRange.end.toISODate()}`);
    }
    
    lines.push('');
    lines.push('---');
    lines.push('');

    // Summary statistics
    const totalEvents = Array.from(groupedEvents.values()).reduce((sum, events) => sum + events.length, 0);
    const platformStats = this.getPlatformStats(groupedEvents);
    
    lines.push('## Summary');
    lines.push('');
    lines.push(`- **Total Events:** ${totalEvents}`);
    lines.push(`- **Active Days:** ${groupedEvents.size}`);
    lines.push('- **Events by Platform:**');
    
    for (const [platform, count] of Object.entries(platformStats)) {
      lines.push(`  - ${this.capitalize(platform)}: ${count}`);
    }
    
    lines.push('');
    lines.push('---');
    lines.push('');

    // Timeline events grouped by date
    lines.push('## Timeline');
    lines.push('');

    for (const [dateKey, events] of groupedEvents) {
      const date = DateTime.fromISO(dateKey);
      const dayName = date.toFormat('cccc');
      const formattedDate = date.toFormat('MMMM dd, yyyy');
      
      // Date header
      lines.push(`### ${dayName}, ${formattedDate}`);
      lines.push('');

      // Sort events by time (most recent first)
      const sortedEvents = events.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());

      for (const event of sortedEvents) {
        lines.push(this.formatEventAsMarkdown(event));
        lines.push('');
      }

      lines.push('---');
      lines.push('');
    }

    // Footer
    lines.push('## Legend');
    lines.push('');
    lines.push('**Platform Icons:**');
    lines.push('- ğŸ¦ Twitter');
    lines.push('- ğŸ¤– Reddit');
    lines.push('- ğŸ’» GitHub');
    lines.push('- ğŸ“° RSS/Blog');
    lines.push('- ğŸ“‹ Pastebin');
    lines.push('');
    lines.push('**Event Types:**');
    lines.push('- ğŸ“ Post/Tweet');
    lines.push('- ğŸ’¬ Comment/Reply');
    lines.push('- â­ Reaction/Like');
    lines.push('- ğŸ”§ Code Commit');
    lines.push('- ğŸ†• Create Repository');
    lines.push('- ğŸ“¤ Push/Deploy');
    lines.push('- ğŸ”€ Pull Request');
    lines.push('- ğŸ“„ Blog Post');
    lines.push('- ğŸ“‹ Code Snippet');
    lines.push('');
    lines.push(`*Timeline generated by Cross-Platform Activity Timeline Builder*`);

    return lines.join('\n');
  }

  /**
   * Format a single event as Markdown
   */
  private formatEventAsMarkdown(event: TimelineEvent): string {
    const time = event.timestamp.toFormat('HH:mm');
    const platformIcon = this.getPlatformIcon(event.platform);
    const categoryIcon = this.getCategoryIcon(event.category);
    
    const lines: string[] = [];
    
    // Event header with time and icons
    lines.push(`**${time}** ${platformIcon} ${categoryIcon} **[${event.title}](${event.url})**`);
    
    // Content (truncated if too long)
    if (event.content) {
      const truncatedContent = event.content.length > 200 
        ? event.content.substring(0, 200) + '...'
        : event.content;
      
      lines.push(`> ${truncatedContent.replace(/\n/g, ' ')}`);
    }
    
    // Metadata
    const metadata: string[] = [];
    
    if (event.username && event.username !== 'unknown') {
      metadata.push(`ğŸ‘¤ @${event.username}`);
    }
    
    if (event.metadata.score !== undefined) {
      metadata.push(`â­ ${event.metadata.score}`);
    }
    
    if (event.metadata.numComments !== undefined) {
      metadata.push(`ğŸ’¬ ${event.metadata.numComments}`);
    }
    
    if (event.metadata.repository) {
      metadata.push(`ğŸ“ ${event.metadata.repository}`);
    }
    
    if (metadata.length > 0) {
      lines.push(`*${metadata.join(' â€¢ ')}*`);
    }

    return lines.join('  \n'); // Two spaces for line break in Markdown
  }

  /**
   * Get platform statistics
   */
  private getPlatformStats(groupedEvents: Map<string, TimelineEvent[]>): Record<string, number> {
    const stats: Record<string, number> = {};
    
    for (const events of groupedEvents.values()) {
      for (const event of events) {
        stats[event.platform] = (stats[event.platform] || 0) + 1;
      }
    }
    
    return stats;
  }

  /**
   * Get platform icon/emoji
   */
  private getPlatformIcon(platform: string): string {
    const icons: Record<string, string> = {
      twitter: 'ğŸ¦',
      reddit: 'ğŸ¤–',
      github: 'ğŸ’»',
      rss: 'ğŸ“°',
      pastebin: 'ğŸ“‹'
    };
    return icons[platform] || 'ğŸ“±';
  }

  /**
   * Get category icon/emoji
   */
  private getCategoryIcon(category: string): string {
    const icons: Record<string, string> = {
      post: 'ğŸ“',
      comment: 'ğŸ’¬',
      share: 'ğŸ”„',
      reaction: 'â­',
      code_commit: 'ğŸ”§',
      code_create: 'ğŸ†•',
      code_push: 'ğŸ“¤',
      code_pr: 'ğŸ”€',
      blog_post: 'ğŸ“„',
      article: 'ğŸ“°',
      paste: 'ğŸ“‹',
      snippet: 'ğŸ“‹',
      other: 'ğŸ“'
    };
    return icons[category] || 'ğŸ“';
  }

  /**
   * Capitalize first letter of a string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}